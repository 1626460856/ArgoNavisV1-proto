// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.4
// - protoc             v6.31.1
// source: api/groupManage/v1/group_manage.proto

package groupManage

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationGroupManageCreateGroup = "/GroupManage.GroupManage/CreateGroup"
const OperationGroupManageDeleteGroup = "/GroupManage.GroupManage/DeleteGroup"
const OperationGroupManageUpdateGroup = "/GroupManage.GroupManage/UpdateGroup"

type GroupManageHTTPServer interface {
	// CreateGroup 新建群组
	CreateGroup(context.Context, *CreateGroupReq) (*CommonResp, error)
	// DeleteGroup 删除群组
	DeleteGroup(context.Context, *DeleteGroupReq) (*CommonResp, error)
	// UpdateGroup 修改群组
	UpdateGroup(context.Context, *UpdateGroupReq) (*CommonResp, error)
}

func RegisterGroupManageHTTPServer(s *http.Server, srv GroupManageHTTPServer) {
	r := s.Route("/")
	r.POST("/group/delete", _GroupManage_DeleteGroup0_HTTP_Handler(srv))
	r.POST("/group/create", _GroupManage_CreateGroup0_HTTP_Handler(srv))
	r.POST("/group/update", _GroupManage_UpdateGroup0_HTTP_Handler(srv))
}

func _GroupManage_DeleteGroup0_HTTP_Handler(srv GroupManageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteGroupReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGroupManageDeleteGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteGroup(ctx, req.(*DeleteGroupReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CommonResp)
		return ctx.Result(200, reply)
	}
}

func _GroupManage_CreateGroup0_HTTP_Handler(srv GroupManageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateGroupReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGroupManageCreateGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateGroup(ctx, req.(*CreateGroupReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CommonResp)
		return ctx.Result(200, reply)
	}
}

func _GroupManage_UpdateGroup0_HTTP_Handler(srv GroupManageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateGroupReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationGroupManageUpdateGroup)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateGroup(ctx, req.(*UpdateGroupReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CommonResp)
		return ctx.Result(200, reply)
	}
}

type GroupManageHTTPClient interface {
	CreateGroup(ctx context.Context, req *CreateGroupReq, opts ...http.CallOption) (rsp *CommonResp, err error)
	DeleteGroup(ctx context.Context, req *DeleteGroupReq, opts ...http.CallOption) (rsp *CommonResp, err error)
	UpdateGroup(ctx context.Context, req *UpdateGroupReq, opts ...http.CallOption) (rsp *CommonResp, err error)
}

type GroupManageHTTPClientImpl struct {
	cc *http.Client
}

func NewGroupManageHTTPClient(client *http.Client) GroupManageHTTPClient {
	return &GroupManageHTTPClientImpl{client}
}

func (c *GroupManageHTTPClientImpl) CreateGroup(ctx context.Context, in *CreateGroupReq, opts ...http.CallOption) (*CommonResp, error) {
	var out CommonResp
	pattern := "/group/create"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationGroupManageCreateGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *GroupManageHTTPClientImpl) DeleteGroup(ctx context.Context, in *DeleteGroupReq, opts ...http.CallOption) (*CommonResp, error) {
	var out CommonResp
	pattern := "/group/delete"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationGroupManageDeleteGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *GroupManageHTTPClientImpl) UpdateGroup(ctx context.Context, in *UpdateGroupReq, opts ...http.CallOption) (*CommonResp, error) {
	var out CommonResp
	pattern := "/group/update"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationGroupManageUpdateGroup))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
